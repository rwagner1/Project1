%Hauptfunktion
%Bekommt Parameter von main_initialize_system und gibt ???? aus

function[path_length]= main_main(alpha, beta_0, no_agents, data_set, rounds, q0)



%Auslesen der Anzahl St√§dte
no_cities = length (data_set(1));									%L√§nge der ersten Spalte der Matrix auslesen

%Memory der Ameise, Matrix mit Anzahl St√§dten x Anzahl Agents
%1 heisst noch nicht besucht.
M_k = ones(no_cities, no_agents);
tau = zeros (no_cities);											%tau als pheromenin-matrix mit dimension no_cities x no_cities, zu beginn alles null

%Berechnen von L_nn, ben√∂tigt f√ºr tau0

L_nn = calc_Lnn(data_set, no_cities);								%Function calc_Lnn aufrufen um L_nn zu berechnen
tau0 = 1/(no_cities*L_nn);



start_city = 1; 													%Agent startet bei erster Stadt
M_k(start_city, :) = 0;                                             %Memory f¸r Startcity auf "besucht"



%-------------------------------------------------------------------------------
%Start der Berechnung mit "rounds"-Durchg√§ngen
%-------------------------------------------------------------------------------


for ii = 1:rounds
    
    path_length = zeros(no_agents,1);
    trajectory = ones(no_cities, no_agents)*start_city                  %Matrix mit nummer der Startstadt auf allen positionen
    

	for current_agent = 1:no_agents
        
        current_city = start_city;                                      %Startstadt bekannt geben
        traj_pos = 2;                                                   %die position in der Trajectory matrix

		while sum(M_k(:, current_agent)) > 0							%Solange es noch unbesuchte St√§dte gibt

			city_s = choose_city(tau,beta0, M_k(:,current_agent), current_city, no_cities, current_agent, q0);              %W‰hle eine Stadt
            M_k(city_s, current_agent) = 0;                                                                                 %Memory dass stadt city_s besucht wurde
            
            %---------------pfadl‰nge-------------------
            if current_city < city_s
                
                path_length(current_agent) = path_length(current_agent) + data_set(current_city, city_s);
                
            else
                
                path_length(current_agent) = path_length(current_agent) + data_set(city_s, current_city);
                
            end
            %--------------------------------------------
            
            trajectory(traj_pos, current_agent) = city_s;                                               %Trajectorymatrix updaten
            traj_pos = traj_pos + 1;                                                                    %n‰chste Position f¸r n‰chsten durchgang

        end  %while

		path_length(current_agent) = path_length(current_agent) + data_set(current_city, start_city);						%Weg nach Hause dazu addieren
		M_k(:, current_agent) = 1;																							%Die Memory auf Anfang setzten

		tau(start_city, current_city) = (1-alpha)*tau(start_city, current_city)+alpha*tau0;									%Pheromaninupdate f¸r nachhause weg

		%------------------------
		%Finde shortest path
		%------------------------

		if current_agent == 1											%Erster Path als shortest setzen														
			shortest_path = path_length(current_agent);
		else   															%F√ºr alle weiteren Agents vergleichen
										
			if path_length(current_agent) < shortest_path

				shortest_path = path_length(current_agent);
				shortest_path_index = current_agent;					%Welcher Agent hatte shortest path, wird ben√∂tigt um sp√§ter globales phenomanim update zu machen


			end

		end

		%------shortest path gefunden-------------

	end  %current_agent ------ Wir haben Shortest_path gefunden und den Agent, der ihn machte (f¸r trajectory benˆtigt)

	%-----------------------------------------------------
	%Globales Update
	%-----------------------------------------------------
    
    tau = global_pheromene_update(trajectory(:, shortest_path_index), tau, shortest_path, no_cities, alpha )



end %ii


		

